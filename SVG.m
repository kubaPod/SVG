(* Wolfram Language Package *)

BeginPackage["SVG`"]
  
  	ExportSVG;

Begin["`Private`"] (* Begin Private Context *) 


		(*List is included since we have to handle it separately too, more info later*)
	primitiveQ[expr_] := MemberQ[{Disk, List}, Head@expr];
	
		(*list of directives that FE uses to render stuff when there is nothing but a primitive given by user*)
	defaultDirectives = {Black, Thickness@Medium};
	
	
	ExportSVG[gr_Graphics]:= distributeDirectives @ First @ gr (*temp def till we finish*)
	
	
	
	
(*********************directives distribution***************************)


	distributeDirectives::usage:="dD[{graphics content}] returns {{directives.., primitive1}, {directives.., primitive2}}";
	
	distributeDirectives[graphicsContent_List] := First @ Last @ Reap @ splitAndAccumulate[
		Join[defaultDirectives, graphicsContent]
	];


		(* split part basically turns {Red, Disk[], Orange, Circle[]} 
		   into {{Red, Disk[]}, {Orange, Circle[]}} and passes it
		   to the accumulation procedure*)
	splitAndAccumulate = accumulate @ Split[#,  Not @ primitiveQ[#] &  ] &;


		(* the last element in each sublist is a primitive so we are accumulating Most of it *)
	accumulate = Rest @ FoldList[passDirectives @ Join[Most @ #, #2] &, {1}, #] &;

	  (*I changed the name of mergeDirectives from the very first commit to passDirectives
		  because it is what this function really does and merging happens later *)
		(*TODO, Sow merged directives, not it Sows everything that was accumulated*)
  passDirectives[{previousDirs__, {nestedGraphics__}}] := {
		previousDirs, splitAndAccumulate@{previousDirs, nestedGraphics}
	};

  passDirectives[{previousDirs__, primitive_}] := {
		previousDirs,  Sow@{mergeDirectives[{previousDirs, primitive}]}
	};


  mergeDirectives[{directives__,primitive_}]:= Module[{attr},
			(*we are going to map through directives with respect to the primitive*)
			(*and leave appriopriate svg attributes spec which later are going to be *)
			(*unioned(?) by Association*)
		attr = mergeDirectives[Head[primitive], #]& /@ {directives} // Association // Normal;

			(* now we are add ing attributes generated by primitive itself, like cx cy r for a circle*)
		attr = Join[attr, primitiveSpecConv[primitive]];

		XMLElement[
			primitiveNameConv @ primitive,
      attr,
			{}
		]
	];


	  (*I could just create an association with key names given by primitives heads
	    but it's quite a commitment. maybe we will need to specify the svg tag name
	    using also the content of the primitive, pattern matching approach leaves
	    more freedom*)
	primitiveNameConv[primitive_[content___]] := Switch[primitive,
	      Disk|Circle, "circle"

	]

  mergeDirectives[Circle, c_?ColorQ]:= "stroke" -> colorConversion @ c;

  mergeDirectives[_, c_?ColorQ]:= "fill" -> colorConversion @ c;

  mergeDirectives[__]:=##&[];

	(*TODO ColorConversion*)
  colorConversion = ToString;

	(*TODO Disk[] -> Disk[{0,0},1] -> cx cy z spec   etc. *)
  primitiveSpecConv[_]={"posSpec"->"to be done"};


	
	
	
	

End[] (* End Private Context *)

EndPackage[]